///
arr = [[2, 3, 5], [4, 2, 5]]
np_arr = np.array(arr)
print(np_arr.shape)
→(2, 3)

///
arr = [[2, 3, 5], [4, 2, 5,4]]
np_arr = np.array(arr)
print(np_arr.shape)
→4: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If 
you meant to do this, you must specify 'dtype=object' when creating the ndarray.
→(2,)
 配列の要素数は同じでなければ警告が出る。
 ただし、出力はされる。

///
arr = [[[2, 3, 5,4], [4, 2, 5,4],[4, 2, 5,4]],[[2, 3, 5,4], [4, 2, 5,4],[4, 2, 5,4]]]
np_arr = np.array(arr)
c3 = np_arr.ravel()
c3 = np_arr.flatten()
print(c3)
→[2 3 5 4 4 2 5 4 4 2 5 4 2 3 5 4 4 2 5 4 4 2 5 4]
 ravelとflattenは，　
 多次元配列を１次元配列に変換する。
 それぞれの違いとして、
 ravelは参照を返し、
 flattenはコピーを返す。

 参照された対象のデータを変更した場合、
 参照元も変更される。
 対して、コピーの場合参照元は変更されない。

///
numpy配列は型指定をしない限り、np.int64が指定される
※型指定方法の例
d = np.array([1,3], dtype=np.int16)　

///
arr = [[2, 3, 5,4], [4, 2, 5,4],[4, 2, 5,4]]
np_arr = np.array(arr)
print(np_arr[:,1])
→[3 2 2]
 行方向全てで、列方向の２番めを取得している。

///
np.arrayはミュータブルであるため、
中の値を書き換えることが可能

///
py_list1 = [0, 1]
#スライスした結果を変数に渡す。
py_list2 = py_list1[:]
py_list2[0] = 3
→[0, 1]
 [3, 1]

np_list1 = np.array([0, 1])
#スライスした結果を変数に渡す。
np_list2 = np_list1[:]
np_list2[0] = 3
print(np_list1)
print(np_list2)
→[3 1]
 [3 1]

 python標準のリストではスライスした結果はコピー扱いであるが、
 numpyでは参照扱いとなる。


///
pythonのrange関数と同じ機能をnumpyは持っている
→range(10) == np.arrange(10)

///
np.random.randomは０～１の間をランダムに取得
f = np.random.random(3)
print(f)
→[0.11114493 0.44762525 0.31653557]

#多次元配列で行う場合はその分の括弧が必要
f = np.random.random((3,2))
print(f)
→[[0.58945361 0.00808273]
 [0.6986799  0.6853774 ]
 [0.18014917 0.45268043]]

np.random.randも０～１の間をランダムに取得
ただしタプルにして渡さない
f = np.random.rand(3,2)
print(f)
→[[0.35816443 0.4757334 ]
 [0.80360976 0.52031493]
 [0.84793123 0.04381827]]

整数のランダム値を取得したい場合、np.random.randintを使用する
f = np.random.randint(1,10)
print(f)
→5

少数点含めた値のランダム値を出したい場合、np.random.uniformを使用する
f = np.random.uniform(0,10,size=(2,4))
print(f)
[[0.33025024 3.8553314  9.24510118 4.52098287]
 [3.05157065 9.46545472 8.99711183 5.71778238]]

///
指定範囲で均等割りデータを作るのは、linspace関数を使用する。
f = np.linspace(0,np.pi,5)
print(f)
→[0.         0.78539816 1.57079633 2.35619449 3.14159265]

///
ドット積の計算は、
np.dot(b,a)
b @ a

///
要素全てに対して真偽値を出力
f = np.array([[3, 3, 4], [3, 3, 4]])
print(f > 3)
→[[False False  True] 
 [False False  True]]

///
０以外の要素数を出力
f = np.array([[3, 3, 4], [3, 3, 4]])
print(np.count_nonzero(f>0))
→6

///
配列同士が同じ要素で構成されているかを判定
np.allclose(b,c)
誤差の範囲を第三引数にして可能
np.allclose(b,c,atol=5)
